#!/usr/bin/env python3

from typing import Optional, List
from enum import Enum
from OpenSSL import crypto, SSL
from pathlib import Path
import os
from configparser import ConfigParser
import typer
import click

main_app = typer.Typer()
ca_app = typer.Typer()
cert_app = typer.Typer()
main_app.add_typer(ca_app, name="ca")
main_app.add_typer(cert_app, name="cert")


class MessageDigest(str, Enum):
    sha256 = "sha256"
    sha512 = "sha512"


class Cipher(str, Enum):
    des3 = "des3"
    aes128 = "aes128"
    aes192 = "aes192"
    aes256 = "aes256"


@main_app.callback()
def callback(
    ctx: typer.Context,
    config: Optional[Path] = typer.Option(
        None,
        envvar="CONFIG",
        help="Ini format config file",
        dir_okay=False,
        exists=False,
        readable=True,
    ),
):
    """Callback Docstring"""
    if config and config.exists():
        ini = ConfigParser()
        ini.read_string(config.read_text())
        for k, v in ini["default"].items():
            envname = k.upper()
            if not envname in os.environ:
                os.environ[envname] = v


@ca_app.command(name="key")
def ca_key(
    ca_key_file: str = typer.Argument(
        ..., envvar="CA_KEY_FILE", help="File name to write private key to."
    ),
    bits: Optional[int] = typer.Option(
        4096,
        "--ca-key-bits",
        "--bits",
        "-b",
        envvar="CA_KEY_BITS",
        help="Size of generated key, in bits.",
    ),
    cipher: Optional[Cipher] = typer.Option(
        Cipher.aes256,
        "--cipher",
        "-C",
        envvar="CA_CIPHER",
        help="Cipher to use to encrypt CA key.",
    ),
    passphrase: str = typer.Option(
        ...,
        envvar="CA_PASSPHRASE",
        help="Passphrase for CA key",
        prompt=True,
        confirmation_prompt=False,
        hide_input=True,
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    overwrite: bool = typer.Option(
        False, help="Overwrite the key file if it already exists."
    ),
):
    """GenCA HELP"""
    if not overwrite and os.path.exists(ca_key_file):
        typer.echo(
            'Key file already exists, will not overwrite without "--overwrite" option.'
        )
        raise typer.Exit(code=1)

    if prompt_for_passphrase:
        passphrase = click.prompt("Passphrase", hide_input=True)

    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)

    with open(ca_key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(
                crypto.FILETYPE_PEM,
                key,
                cipher=cipher,
                passphrase=passphrase.encode("ascii"),
            ).decode("ascii")
        )


@main_app.command(name="showkey")
def main_showkey(
    key_file: str = typer.Argument(
        ..., envvar="KEY_FILE", help="Key file to show information about."
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    passphrase: str = typer.Option(
        None,
        "-P",
        envvar="PASSPHRASE",
        help="Passphrase for key",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
):
    """Show CA key HELP"""

    if not no_passphrase and passphrase is None:
        passphrase = click.prompt("Passphrase", hide_input=True)
    if passphrase:
        passphrase = passphrase.encode("ascii")
    if no_passphrase:
        passphrase = None

    with open(key_file, "rt") as f:
        try:
            key = crypto.load_privatekey(
                crypto.FILETYPE_PEM, f.read(), passphrase=passphrase
            )
        except crypto.Error as e:
            error = " ".join(e.args[0][0])
            typer.echo(f"Failed to load key: {error}")
            raise typer.Exit(code=1)

    type_name = str(key.type())
    if key.type() == crypto.TYPE_RSA:
        type_name = "RSA"
    if key.type() == crypto.TYPE_DSA:
        type_name = "DSA"

    print(f"Bits: {key.bits()}  Type: {type_name}")


def get_next_serial(path):
    if not path:
        return 0

    if not path.exists():
        with path.open("w") as fp:
            fp.write("1\n")
        return 0

    with path.open("r") as fp:
        next_serial = int(fp.readline().strip(), 16)
    with path.open("w") as fp:
        fp.write(f"{next_serial+1:X}\n")
    return next_serial


@cert_app.command(name="gen")
def cert(
    common_name: str = typer.Argument(
        ..., envvar="SUBJECT_CN", help="Main name on certificate"
    ),
    cert_file: str = typer.Argument(
        ..., envvar="CERT_FILE", help="File name to write certificate to."
    ),
    key_file: str = typer.Argument(
        ..., envvar="KEY_FILE", help="File name to write private key to."
    ),
    serial_file: Path = typer.Option(
        None,
        envvar="SERIAL_FILE",
        help="File that has the next serial number in it.  "
        "If undefined or a non-existant file, serial 0 is used.",
    ),
    index_file: Path = typer.Option(
        None,
        envvar="INDEX_FILE",
        help="File to write the certificate information to (ca database).",
    ),
    valid_days: Optional[int] = typer.Option(
        ...,
        "--valid-days",
        "-d",
        envvar="VALID_DAYS",
        help="Number of days the certificate is valid for",
    ),
    subject_alternative_names: Optional[List[str]] = typer.Option(
        None,
        "--san",
        "-s",
        help="Subject alternative names for certificate, the Common Name is added to this list.",
    ),
    bits: Optional[int] = typer.Option(
        ...,
        "--bits",
        "-b",
        envvar="BITS",
        help="Size of generated key, in bits.",
    ),
    digest: Optional[MessageDigest] = typer.Option(
        ...,
        "--digest",
        "-D",
        envvar="DIGEST",
        help="Message digest to use.",
    ),
    append_domain: Optional[str] = typer.Option(
        None,
        "--append-domain",
        "-a",
        envvar="APPEND_DOMAIN",
        help="If provided, this value is appended to all domain names (CN, SAN) so short names can be used.",
    ),
    country_name: str = typer.Option(
        ...,
        "--country-name",
        "--C",
        "-C",
        envvar="SUBJECT_C",
        help="Subject: Country name",
    ),
    state_name: str = typer.Option(
        ...,
        "--state-name",
        "--ST",
        "-ST",
        envvar="SUBJECT_ST",
        help="Subject: State name",
    ),
    locality_name: str = typer.Option(
        ...,
        "--locality-name",
        "--L",
        "-L",
        envvar="SUBJECT_L",
        help="Subject: Locality(city) name",
    ),
    organization_name: str = typer.Option(
        ...,
        "--organization-name",
        "--O",
        "-O",
        envvar="SUBJECT_O",
        help="Subject: Organization name",
    ),
    organization_unit_name: Optional[str] = typer.Option(
        None,
        "--organization-unit-name",
        "--OU",
        "-OU",
        envvar="SUBJECT_OU",
        help="Subject: Organization unit name",
    ),
    email_address: str = typer.Option(
        ...,
        "--email-address",
        "-E",
        envvar="SUBJECT_EMAIL",
        help="Subject: Email address",
    ),
    passphrase: str = typer.Option(
        None,
        "-P",
        envvar="CERT_PASSPHRASE",
        help="Passphrase for key",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
):
    """Cert HELP"""

    cert = crypto.X509()
    cert.get_subject().C = country_name
    cert.get_subject().ST = state_name
    cert.get_subject().L = locality_name
    cert.get_subject().O = organization_name
    if organization_unit_name:
        cert.get_subject().OU = organization_unit_name
    cert.get_subject().CN = common_name
    cert.get_subject().emailAddress = email_address

    if append_domain:
        common_name = common_name + append_domain

    san_list = [f"DNS:{common_name}".encode("ascii")]

    if subject_alternative_names:
        for san in subject_alternative_names:
            if append_domain:
                san = san + append_domain
            if not san.startswith("DNS:"):
                san = "DNS:" + san
            san_list.append(san.encode("ascii"))

    cert.add_extensions(
        [
            crypto.X509Extension(b"subjectAltName", False, b", ".join(san_list)),
        ]
    )

    serial_number = get_next_serial(serial_file)
    cert.set_serial_number(serial_number)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(valid_days * 86500)
    cert.set_issuer(cert.get_subject())

    if index_file:
        cert_not_after = cert.get_notAfter().decode("ascii")[2:]
        cert_dn = str(cert.get_subject()).split("'")[1]
        ca_db_line = f"V\t{cert_not_after}\t\t{serial_number:X}\tunknown\t{cert_dn}\n"

        with index_file.open("a") as fp:
            fp.write(ca_db_line)

    # create a key pair
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)

    if not no_passphrase and passphrase is None:
        passphrase = click.prompt("Passphrase", hide_input=True)
    if passphrase:
        passphrase = passphrase.encode("ascii")
    if no_passphrase:
        passphrase = None

    cert.set_pubkey(key)
    cert.sign(key, digest)
    with open(cert_file, "wt") as f:
        f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode("ascii"))
    with open(key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(
                crypto.FILETYPE_PEM,
                key,
                passphrase=passphrase,
            ).decode("ascii")
        )


if __name__ == "__main__":
    main_app()
