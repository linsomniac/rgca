#!/usr/bin/env python3

from typing import Optional, List, Union
from enum import Enum
from OpenSSL import crypto, SSL
from pathlib import Path
import os
from configparser import ConfigParser
import subprocess
import shlex
import typer
import click
from jinja2 import Template

main_app = typer.Typer()
ca_app = typer.Typer()
cert_app = typer.Typer()
main_app.add_typer(ca_app, name="ca")
main_app.add_typer(cert_app, name="cert")


class MessageDigest(str, Enum):
    sha256 = "sha256"
    sha512 = "sha512"


class Cipher(str, Enum):
    des3 = "des3"
    aes128 = "aes128"
    aes192 = "aes192"
    aes256 = "aes256"


@main_app.callback()
def callback(
    ctx: typer.Context,
    config: Optional[Path] = typer.Option(
        os.path.expanduser("~/.config/rgca/config.ini"),
        envvar="CONFIG",
        help="Ini format config file",
        dir_okay=False,
        exists=False,
        readable=True,
    ),
    config_group: str = typer.Option(
        "DEFAULT",
        envvar="CONFIG_GROUP",
        help="Additional group to pull settings from.  If set, named group in the "
        "config file will be loaded in addition to 'DEFAULT'.",
    ),
):
    """rgca is a Certificate Authority helper, to make creating certificates, either from scripts
    or from the CLI, easier.  All (reasonable) values can be passed either by CLI arguments, config
    files, or the environment.  See the help for the sub commands for more information, but an example
    use could be:

        rgca cert new www.example.com www.crt www.key

    The above command is incomplete, as it doesn't specify various Subject items like Country, Locality,
    Organization, etc...  But if you run the above, it will tell you what is missing.  A more complete
    run might look like:

        rgca cert new --C US --ST Colorado --L Denver --O Example -E user@example.com \
              www.example.com www.crt www.key

    Or, if you specify subject items in a config file:

        rgca --config config.ini cert new www.example.com www.crt www.key

    It is compatible with OpenSSL commands (including managing the "serial" and "index.txt" files).

    A config file may be specified in "INI" format.  There is a "DEFAULT" group that is always read,
    and other sections may be selected using the "--config-group" option, so that multiple
    configurations may be easliy switched between.

    Values may also be set using the environment.  Options that can be set from the environment are
    listed in the help related to those options.

    For example, take this "config.ini":

        [DEFAULT]
        SUBJECT_C=US
        SUBJECT_ST=Colorado
        SUBJECT_L=Denver
        SUBJECT_O=Example
        SUBJECT_OU=Corporate
        SUBJECT_EMAIL=admin@example.com

        [widget]
        SUBJECT_OU=Widgets
        SUBJECT_EMAIL=admin@widgets.example.com

    Then you can run it with:

        rgca --config config.ini cert new www.example.com www.crt www.key
        rgca --config config.ini --config-group widget cert new widgets.example.com widgets.crt widgets.key
    """
    if config and config.exists():
        ini = ConfigParser()
        ini.read_string(config.read_text())

        for k, v in ini[config_group].items():
            envname = k.upper()
            if envname not in os.environ:
                os.environ[envname] = v


def get_passphrase(
    passphrase: Union[str, None],
    no_passphrase: bool,
    prompt_for_passphrase: bool,
    key_type: str,
    confirm: bool = False,
) -> Union[bytes, None]:
    """@@@"""
    retval = passphrase

    if no_passphrase:
        return None
    if prompt_for_passphrase or passphrase is None:
        retval = click.prompt(
            f"{key_type} Passphrase", hide_input=True, confirmation_prompt=confirm
        )
    if type(retval) is str:
        return retval.encode("ascii")

    return retval


@ca_app.command(name="newkey")
def ca_newkey(
    ca_key_file: str = typer.Argument(
        ..., envvar="CA_KEY_FILE", help="File name to write private key to."
    ),
    bits: int = typer.Option(
        8192,
        "--ca-key-bits",
        "--bits",
        "-b",
        envvar="CA_KEY_BITS",
        help="Size of generated key, in bits.",
    ),
    cipher: Optional[Cipher] = typer.Option(
        Cipher.aes256,
        "--cipher",
        "-c",
        envvar="CA_CIPHER",
        help="Cipher to use to encrypt CA key.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        envvar="CA_PASSPHRASE",
        help="Passphrase for CA key",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
    overwrite: bool = typer.Option(
        False, help="Overwrite the key file if it already exists."
    ),
):
    """GenCA HELP"""
    if not overwrite and os.path.exists(ca_key_file):
        typer.echo(
            'Key file already exists, will not overwrite without "--overwrite" option.'
        )
        raise typer.Exit(code=1)

    final_passphrase = get_passphrase(
        passphrase, no_passphrase, prompt_for_passphrase, "CA", confirm=True
    )

    if no_passphrase:
        cipher = None

    print("Generating key, this may take a moment...")
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)

    with open(ca_key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(
                crypto.FILETYPE_PEM, key, cipher=cipher, passphrase=final_passphrase
            ).decode("ascii")
        )


@main_app.command(name="showkey")
def main_showkey(
    key_file: str = typer.Argument(
        ..., envvar="KEY_FILE", help="Key file to show information about."
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        "--prompt-for-passphrase",
        "-P",
        envvar="PASSPHRASE",
        help="Passphrase for key",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
):
    """Show key HELP"""

    final_passphrase = get_passphrase(
        passphrase, no_passphrase, prompt_for_passphrase, "Keyfile"
    )

    with open(key_file, "rt") as f:
        try:
            key = crypto.load_privatekey(
                crypto.FILETYPE_PEM, f.read(), passphrase=final_passphrase
            )
        except crypto.Error as e:
            error = " ".join(e.args[0][0])
            typer.echo(f"Failed to load key: {error}")
            raise typer.Exit(code=1)

    type_name = str(key.type())
    if key.type() == crypto.TYPE_RSA:
        type_name = "RSA"
    if key.type() == crypto.TYPE_DSA:
        type_name = "DSA"

    print(f"Bits: {key.bits()}  Type: {type_name}")


def get_next_serial(path: Path) -> int:
    """Load the next serial number from `path`.

    Args:
        path: File containing the next serial number in hex representation.

    Returns:
        The next serial number as integer.
    """
    if not path:
        return 0

    if not path.exists():
        with path.open("w") as fp:
            fp.write("1\n")
        return 0

    with path.open("r") as fp:
        next_serial = int(fp.readline().strip(), 16)
    with path.open("w") as fp:
        fp.write(f"{next_serial+1:X}\n")
    return next_serial


def run_deploy(deploy_command: str, env: dict) -> int:
    """Run the deploy command to deliver keys.

    Args:
        - deploy_command: Command to run to do a deploy.  This is parsed with shlex.split().
        - env: Environment values set before running.

    Returns:
        0 on success, process exit code on failure.
    """
    try:
        subprocess.run(shlex.split(deploy_command), check=True, env=env)
        return 0
    except subprocess.CalledProcessError as e:
        return e.returncode


@cert_app.command(name="new")
def cert(
    common_name: str = typer.Argument(
        ..., envvar="SUBJECT_CN", help="Main name on certificate"
    ),
    cert_file: str = typer.Option(
        "{{ SUBJECT_CN }}.crt",
        envvar="CERT_FILE", help="File name to write certificate to.  This name can be "
                "jinja2 templated from the environment."
    ),
    key_file: str = typer.Option(
        "{{ SUBJECT_CN }}.key",
        envvar="KEY_FILE", help="File name to write private key to.  This name can be "
                "jinja2 templated from the environment."
    ),
    serial_file: Path = typer.Option(
        None,
        envvar="SERIAL_FILE",
        help="File that has the next serial number in it.  "
        "If undefined or a non-existant file, serial 0 is used.",
    ),
    index_file: Path = typer.Option(
        None,
        envvar="INDEX_FILE",
        help="File to write the certificate information to (ca database).",
    ),
    valid_days: int = typer.Option(
        365,
        "--valid-days",
        "-d",
        envvar="VALID_DAYS",
        help="Number of days the certificate is valid for.",
    ),
    subject_alternative_names: Optional[List[str]] = typer.Option(
        None,
        "--san",
        "-s",
        help="Subject alternative name to add to the certificate.  The Common Name is "
        "listed as the first SAN.",
    ),
    bits: int = typer.Option(
        8192,
        "--bits",
        "-b",
        envvar="BITS",
        help="Size of generated key, in bits.",
    ),
    digest: MessageDigest = typer.Option(
        "sha512",
        "--digest",
        "-D",
        envvar="DIGEST",
        help="Message digest to use when signing the key.",
    ),
    append_domain: Optional[str] = typer.Option(
        None,
        "--append-domain",
        "-a",
        envvar="APPEND_DOMAIN",
        help="If provided, this value is appended to all domain names (CN, SAN) so "
        "short names can be used.  For example this creates a web.example.com "
        "cert without having to repeat '.example.com' all over: rgca cert new "
        "--append-domain example.com --san test --san foo web web.crt web.key",
    ),
    country_name: str = typer.Option(
        ...,
        "--country-name",
        "--C",
        "-C",
        envvar="SUBJECT_C",
        help="Subject: Country name",
    ),
    state_name: str = typer.Option(
        ...,
        "--state-name",
        "--ST",
        "-ST",
        envvar="SUBJECT_ST",
        help="Subject: State name",
    ),
    locality_name: str = typer.Option(
        ...,
        "--locality-name",
        "--L",
        "-L",
        envvar="SUBJECT_L",
        help="Subject: Locality(city) name",
    ),
    organization_name: str = typer.Option(
        ...,
        "--organization-name",
        "--O",
        "-O",
        envvar="SUBJECT_O",
        help="Subject: Organization name",
    ),
    organization_unit_name: Optional[str] = typer.Option(
        None,
        "--organization-unit-name",
        "--OU",
        "-OU",
        envvar="SUBJECT_OU",
        help="Subject: Organization unit name",
    ),
    email_address: str = typer.Option(
        ...,
        "--email-address",
        "--E",
        "-E",
        envvar="SUBJECT_EMAIL",
        help="Subject: Email address",
    ),
    cipher: Optional[Cipher] = typer.Option(
        Cipher.aes256,
        "--cipher",
        "-c",
        envvar="CERT_CIPHER",
        help="Cipher to use to encrypt certificate key.  This is only used if a "
        "passphrase is specified.",
    ),
    ca_file: str = typer.Option(
        ...,
        envvar="CA_KEY_FILE",
        help="File name of the CA key, if specified the "
        "generated cert is signed with this key.  If not specified, the cert "
        "is unsigned.",
    ),
    ca_passphrase: Union[str, None] = typer.Option(
        None,
        "--ca-passphrase",
        envvar="CA_PASSPHRASE",
        help="Passphrase to decrypt the key.  If not specified, and the key is "
        "encrypted, a passphrase will be prompted for.",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.  "
        "Is overridden by --no-passphrase.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        "--passphrase",
        "-P",
        envvar="PASSPHRASE",
        help="Passphrase to encrypt the key.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "--no-passphrase",
        "-N",
        help="Do not put a passphrase on the key file.  This overrides settings in the "
        "config/environment/CLI for --passphrase/--prompt-for-passphrase.",
    ),
    deploy: bool = typer.Option(
        False,
        envvar="DEPLOY",
        help="Use '--deploy-command' to deploy key/cert after generation.",
    ),
    deploy_command: str = typer.Option(
        None,
        "--deploy-command",
        envvar="DEPLOY_COMMAND",
        help="Command to run to deploy cert/key after generation.",
    ),
):
    """Create a new certificate signed by the CA key.

    This is compatible with the OpenSSL CA tools, and can read and write "serial"
    and "index.txt" files as used by OpenSSL.

    Various values for the certificate are given by the options marked with "Subject:".
    Options may be specified from the CLI, environment, or config file (in order
    of what overrides, with CLI overriding environment, then config).  See
    "rgca --help" for more information on the config file.

    If --deploy is set, the command given to --deploy-command is run after the
    certificate has been generated.  It is called with these environment variables
    set:

    DEPLOY: The string "CERT_NEW".

    FILES: A space separated list of the files generated.

    CERT_FILE: The certificate file.

    KEY_FILE: The key file.
    """

    if deploy and deploy_command is None:
        typer.echo(
            "If run with '--deploy', a '--deploy-command' must be specified (can "
            "also be via environment or config DEPLOY_COMMAND)."
        )
        raise typer.Exit(1)

    os.environ['SUBJECT_CN'] = common_name
    cert_file = Template(cert_file).render(os.environ)
    key_file = Template(key_file).render(os.environ)

    cert = crypto.X509()
    cert.get_subject().C = country_name
    cert.get_subject().ST = state_name
    cert.get_subject().L = locality_name
    cert.get_subject().O = organization_name  # NOQA: E741
    if organization_unit_name:
        cert.get_subject().OU = organization_unit_name
    cert.get_subject().CN = common_name
    cert.get_subject().emailAddress = email_address

    if append_domain:
        common_name = common_name + append_domain

    san_list = [f"DNS:{common_name}".encode("ascii")]

    if subject_alternative_names:
        for san in subject_alternative_names:
            if append_domain:
                san = san + append_domain
            if not san.startswith("DNS:"):
                san = "DNS:" + san
            san_list.append(san.encode("ascii"))

    cert.add_extensions(
        [
            crypto.X509Extension(b"subjectAltName", False, b", ".join(san_list)),
        ]
    )

    serial_number = get_next_serial(serial_file)
    cert.set_serial_number(serial_number)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(valid_days * 86500)
    cert.set_issuer(cert.get_subject())

    if ca_file:
        with open(ca_file, "rt") as f:
            capass = ca_passphrase

            def askcapass(_) -> bytes:
                return click.prompt("CA Passphrase to sign key", hide_input=True).encode(
                    "ascii"
                )

            if ca_passphrase is None:
                capass = askcapass
            if type(capass) is str:
                capass = capass.encode("ascii")

            try:
                ca_key = crypto.load_privatekey(
                    crypto.FILETYPE_PEM, f.read(), passphrase=capass
                )
            except crypto.Error as e:
                error = " ".join(e.args[0][0])
                typer.echo(f"Failed to load CA key: {error}")
                raise typer.Exit(code=1)

    if index_file:
        cert_not_after = cert.get_notAfter().decode("ascii")[2:]
        cert_dn = str(cert.get_subject()).split("'")[1]
        ca_db_line = f"V\t{cert_not_after}\t\t{serial_number:X}\t{cert_file}\t{cert_dn}\n"

        with index_file.open("a") as fp:
            fp.write(ca_db_line)

    final_passphrase = get_passphrase(
        passphrase, no_passphrase, prompt_for_passphrase, "Cert", confirm=True
    )
    if no_passphrase:
        cipher = None

    # create a key pair
    print("Generating key, this may take a moment...")
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)
    cert.set_pubkey(key)

    cert.sign(ca_key, digest)

    with open(cert_file, "wt") as f:
        f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode("ascii"))
    with open(key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(
                crypto.FILETYPE_PEM,
                key,
                cipher=cipher,
                passphrase=final_passphrase,
            ).decode("ascii")
        )

    if deploy:
        retval = run_deploy(
            deploy_command,
            {
                "DEPLOY": "CERT_NEW",
                "CERT_FILE": cert_file,
                "KEY_FILE": key_file,
                "FILES": key_file + " " + cert_file,
            },
        )
        if retval != 0:
            typer.echo(f"Deploy command failed, returned {retval} instead of 0")
            raise typer.Exit(1)


if __name__ == "__main__":
    main_app()
