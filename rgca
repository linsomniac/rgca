#!/usr/bin/env python3

from typing import Optional, List, Union
from enum import Enum
from OpenSSL import crypto, SSL
from pathlib import Path
import os
from configparser import ConfigParser
import subprocess
import shlex
import typer
import click
from jinja2 import Template

main_app = typer.Typer()
ca_app = typer.Typer()
cert_app = typer.Typer()
main_app.add_typer(ca_app, name="ca")
main_app.add_typer(cert_app, name="cert")


class MessageDigest(str, Enum):
    sha256 = "sha256"
    sha512 = "sha512"


class CertType(str, Enum):
    server = "server"


class Cipher(str, Enum):
    des3 = "des3"
    aes128 = "aes128"
    aes192 = "aes192"
    aes256 = "aes256"


@main_app.callback()
def callback(
    ctx: typer.Context,
    config: Optional[List[Path]] = typer.Option(
        [".rgca.ini", os.path.expanduser("~/.config/rgca/config.ini")],
        envvar="CONFIG",
        help="Ini format config file",
        dir_okay=False,
        exists=False,
        readable=True,
    ),
    config_group: str = typer.Option(
        "DEFAULT",
        "--config-group",
        "--group",
        "-G",
        envvar="CONFIG_GROUP",
        help="Additional group to pull settings from.  If set, named group in the "
        "config file will be loaded in addition to 'DEFAULT'.",
    ),
):
    """rgca is a Certificate Authority helper, to make creating certificates, either from scripts
    or from the CLI, easier.  All (reasonable) values can be passed either by CLI arguments, config
    files, or the environment.  See the help for the sub commands for more information, but an example
    use could be:

        rgca cert new www.example.com

    The above command is incomplete, as it doesn't specify various Subject items like Country, Locality,
    Organization, etc...  But if you run the above, it will tell you what is missing.  A more complete
    run might look like:

        rgca cert new --C US --ST Colorado --L Denver --O Example -E user@example.com www.example.com

    Or, if you specify subject items in a config file:

        rgca --config config.ini cert new www.example.com www.crt www.key

    It is compatible with OpenSSL commands (including managing the "serial" and "index.txt" files).

    One or more config files may be specified in "INI" format.  Earlier config files override
    values set in later files. There is a "DEFAULT" group that is always read, and other sections
    may be selected using the "--config-group" option, so that multiple configurations may be
    easliy switched between.

    Values may also be set using the environment.  Options that can be set from the environment are
    listed in the help related to those options.

    For example, take this "config.ini":

        [DEFAULT]
        SUBJECT_C=US
        SUBJECT_ST=Colorado
        SUBJECT_L=Denver
        SUBJECT_O=Example
        SUBJECT_OU=Corporate
        SUBJECT_EMAIL=admin@example.com

        [widget]
        SUBJECT_OU=Widgets
        SUBJECT_EMAIL=admin@widgets.example.com

    Then you can run it with:

        rgca --config config.ini cert new www.example.com www.crt www.key
        rgca --config config.ini --config-group widget cert new widgets.example.com widgets.crt widgets.key
    """
    if not config:
        return

    for config_file in config:
        if config_file.exists():
            ini = ConfigParser()
            ini.read_string(config_file.read_text())

            for k, v in ini[config_group].items():
                envname = k.upper()
                if envname not in os.environ:
                    os.environ[envname] = v


def get_passphrase(
    passphrase: Union[str, None],
    no_passphrase: bool,
    prompt_for_passphrase: bool,
    key_type: str,
    confirm: bool = False,
) -> Union[bytes, None]:
    """@@@"""
    retval = passphrase

    if no_passphrase:
        return None
    if prompt_for_passphrase or passphrase is None:
        retval = click.prompt(
            f"{key_type} Passphrase", hide_input=True, confirmation_prompt=confirm
        )
    if type(retval) is str:
        return retval.encode("ascii")

    return retval


@ca_app.command(name="newkey")
def ca_newkey(
    ca_key_file: str = typer.Argument(
        ..., envvar="CA_KEY_FILE", help="File name to write private key to."
    ),
    bits: int = typer.Option(
        8192,
        "--ca-key-bits",
        "--bits",
        "-b",
        envvar="CA_KEY_BITS",
        help="Size of generated key, in bits.",
    ),
    cipher: Optional[Cipher] = typer.Option(
        Cipher.aes256,
        "--cipher",
        "-c",
        envvar="CA_CIPHER",
        help="Cipher to use to encrypt CA key.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        envvar="CA_PASSPHRASE",
        help="Passphrase for CA key",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
    overwrite: bool = typer.Option(
        False, help="Overwrite the key file if it already exists."
    ),
):
    """GenCA HELP"""
    if not overwrite and os.path.exists(ca_key_file):
        typer.echo(
            'Key file already exists, will not overwrite without "--overwrite" option.'
        )
        raise typer.Exit(code=1)

    final_passphrase = get_passphrase(
        passphrase, no_passphrase, prompt_for_passphrase, "CA", confirm=True
    )

    if no_passphrase:
        cipher = None

    print("Generating key, this may take a moment...")
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)

    with open(ca_key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(
                crypto.FILETYPE_PEM, key, cipher=cipher, passphrase=final_passphrase
            ).decode("ascii")
        )


@main_app.command(name="showkey")
def main_showkey(
    key_file: str = typer.Argument(
        ..., envvar="KEY_FILE", help="Key file to show information about."
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        "--prompt-for-passphrase",
        "-P",
        envvar="PASSPHRASE",
        help="Passphrase for key",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
):
    """Show key HELP"""

    final_passphrase = get_passphrase(
        passphrase, no_passphrase, prompt_for_passphrase, "Keyfile"
    )

    with open(key_file, "rt") as f:
        try:
            key = crypto.load_privatekey(
                crypto.FILETYPE_PEM, f.read(), passphrase=final_passphrase
            )
        except crypto.Error as e:
            error = " ".join(e.args[0][0])
            typer.echo(f"Failed to load key: {error}")
            raise typer.Exit(code=1)

    type_name = str(key.type())
    if key.type() == crypto.TYPE_RSA:
        type_name = "RSA"
    if key.type() == crypto.TYPE_DSA:
        type_name = "DSA"

    print(f"Bits: {key.bits()}  Type: {type_name}")


def get_next_serial(path: Path) -> int:
    """Load the next serial number from `path`.

    Args:
        path: File containing the next serial number in hex representation.

    Returns:
        The next serial number as integer.
    """
    if not path:
        return 0

    if not path.exists():
        with path.open("w") as fp:
            fp.write("1\n")
        return 0

    with path.open("r") as fp:
        next_serial = int(fp.readline().strip(), 16)
    with path.open("w") as fp:
        fp.write(f"{next_serial+1:X}\n")
    return next_serial


def run_script(script_command: str, env: dict) -> int:
    """Run the pre/post script command to deliver keys.

    Args:
        - script_command: Command to pre/post processes.  This is parsed with shlex.split().
        - env: Environment values set before running.

    Returns:
        0 on success, process exit code on failure.
    """
    merged_env = os.environ.copy()
    merged_env.update(env)
    try:
        subprocess.run(shlex.split(script_command), check=True, env=merged_env)
        return 0
    except subprocess.CalledProcessError as e:
        return e.returncode


def check_pre_post_args(
    run_pre: bool, pre_command: str, run_post: bool, post_command: str
) -> None:
    """Check the pre and post arguments to make sure they are valid."""
    if run_pre and pre_command is None:
        typer.echo(
            "If run with '--run-pre', a '--pre-command' must be specified (can "
            "also be via environment or config PRE_COMMAND)."
        )
        raise typer.Exit(1)
    if run_post and post_command is None:
        typer.echo(
            "If run with '--run-post', a '--post-command' must be specified (can "
            "also be via environment or config POST_COMMAND)."
        )
        raise typer.Exit(1)


def run_pre_script(run_pre: bool, pre_command: str, add_env: dict = {}) -> None:
    """Run the pre script if arguments specify it.

    Args:
        run_pre: Should the pre script be run.
        pre_command: The command that specifies the pre script.
        add_env: Environment values to be set for command run.
    """

    if run_pre:
        retval = run_script(os.path.expanduser(pre_command), add_env)
        if retval != 0:
            typer.echo(f"Pre command failed, returned {retval} instead of 0")
            raise typer.Exit(1)


def run_post_script(run_post: bool, post_command: str, add_env: dict = {}) -> None:
    """Run the post script if arguments specify it.

    Args:
        run_post: Should the post script be run.
        post_command: The command that specifies the post script.
        add_env: Environment values to be set for command run.
    """
    if run_post:
        retval = run_script(os.path.expanduser(post_command), add_env)
        if retval != 0:
            typer.echo(f"Post command failed, returned {retval} instead of 0")
            raise typer.Exit(1)


def load_ca_key(ca_key_file: str, ca_passphrase: Union[str, None]) -> crypto.PKey:
    """Load the CA private key, asking for passphrase if necessary.

    Returns:
        The key that was loaded."""
    with open(ca_key_file, "rt") as f:
        capass = ca_passphrase

        def askcapass(_) -> bytes:
            return click.prompt("CA Passphrase to sign key", hide_input=True).encode(
                "ascii"
            )

        if ca_passphrase is None:
            capass = askcapass
        if type(capass) is str:
            capass = capass.encode("ascii")

        try:
            return crypto.load_privatekey(
                crypto.FILETYPE_PEM, f.read(), passphrase=capass
            )
        except crypto.Error as e:
            error = " ".join(e.args[0][0])
            typer.echo(f"Failed to load CA key: {error}")
            raise typer.Exit(code=1)


@cert_app.command(name="new")
def cert_new(
    common_name: str = typer.Argument(
        ..., envvar="SUBJECT_CN", help="Main name on certificate"
    ),
    cert_file: str = typer.Option(
        "{{ SUBJECT_CN }}.crt",
        envvar="CERT_FILE",
        help="File name to write certificate to.  This name can be "
        "jinja2 templated from the environment.",
    ),
    key_file: str = typer.Option(
        "{{ SUBJECT_CN }}.key",
        envvar="KEY_FILE",
        help="File name to write private key to.  This name can be "
        "jinja2 templated from the environment.",
    ),
    serial_file: Path = typer.Option(
        None,
        envvar="SERIAL_FILE",
        help="File that has the next serial number in it.  "
        "If undefined or a non-existant file, serial 0 is used.",
    ),
    index_file: Path = typer.Option(
        None,
        envvar="INDEX_FILE",
        help="File to write the certificate information to (ca database).",
    ),
    valid_days: int = typer.Option(
        365,
        "--valid-days",
        "-d",
        envvar="VALID_DAYS",
        help="Number of days the certificate is valid for.",
    ),
    subject_alternative_names: Optional[List[str]] = typer.Option(
        None,
        "--san",
        "-s",
        help="Subject alternative name to add to the certificate.  The Common Name is "
        "listed as the first SAN.",
    ),
    bits: int = typer.Option(
        8192,
        "--bits",
        "-b",
        envvar="BITS",
        help="Size of generated key, in bits.",
    ),
    digest: MessageDigest = typer.Option(
        "sha512",
        "--digest",
        "-D",
        envvar="DIGEST",
        help="Message digest to use when signing the key.",
    ),
    append_domain: Optional[str] = typer.Option(
        None,
        "--append-domain",
        "-a",
        envvar="APPEND_DOMAIN",
        help="If provided, this value is appended to all domain names (CN, SAN) so "
        "short names can be used.  For example this creates a web.example.com "
        "cert without having to repeat '.example.com' all over: rgca cert new "
        "--append-domain example.com --san test --san foo web web.crt web.key",
    ),
    country_name: str = typer.Option(
        ...,
        "--country-name",
        "--C",
        "-C",
        envvar="SUBJECT_C",
        help="Subject: Country name",
    ),
    state_name: str = typer.Option(
        ...,
        "--state-name",
        "--ST",
        "-ST",
        envvar="SUBJECT_ST",
        help="Subject: State name",
    ),
    locality_name: str = typer.Option(
        ...,
        "--locality-name",
        "--L",
        "-L",
        envvar="SUBJECT_L",
        help="Subject: Locality(city) name",
    ),
    organization_name: str = typer.Option(
        ...,
        "--organization-name",
        "--O",
        "-O",
        envvar="SUBJECT_O",
        help="Subject: Organization name",
    ),
    organization_unit_name: Optional[str] = typer.Option(
        None,
        "--organization-unit-name",
        "--OU",
        "-OU",
        envvar="SUBJECT_OU",
        help="Subject: Organization unit name",
    ),
    email_address: str = typer.Option(
        ...,
        "--email-address",
        "--E",
        "-E",
        envvar="SUBJECT_EMAIL",
        help="Subject: Email address",
    ),
    cipher: Optional[Cipher] = typer.Option(
        Cipher.aes256,
        "--cipher",
        "-c",
        envvar="CERT_CIPHER",
        help="Cipher to use to encrypt certificate key.  This is only used if a "
        "passphrase is specified.",
    ),
    ca_cert_file: str = typer.Option(
        ...,
        envvar="CA_CERT_FILE",
        help="File name of the CA certificate, if specified the "
        "generated cert is issued using this certificate.  This needs to be specified "
        "to properly be marked as being issued by the CA.",
    ),
    ca_key_file: str = typer.Option(
        ...,
        envvar="CA_KEY_FILE",
        help="File name of the CA key, if specified the "
        "generated cert is signed with this key.  If not specified, the cert "
        "is unsigned.",
    ),
    ca_passphrase: Union[str, None] = typer.Option(
        None,
        "--ca-passphrase",
        envvar="CA_PASSPHRASE",
        help="Passphrase to decrypt the key.  If not specified, and the key is "
        "encrypted, a passphrase will be prompted for.",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.  "
        "Is overridden by --no-passphrase.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        "--passphrase",
        "-P",
        envvar="PASSPHRASE",
        help="Passphrase to encrypt the key.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "--no-passphrase",
        "-N",
        envvar="NO_PASSPHRASE",
        help="Do not put a passphrase on the key file.  This overrides settings in the "
        "config/environment/CLI for --passphrase/--prompt-for-passphrase.",
    ),
    run_pre: bool = typer.Option(
        False,
        envvar="RUN_PRE",
        help="Use '--pre-command' before certificate generation.",
    ),
    pre_command: str = typer.Option(
        None,
        "--pre-command",
        envvar="PRE_COMMAND",
        help="Command to run to before starting certificate generation.",
    ),
    run_post: bool = typer.Option(
        False,
        envvar="RUN_POST",
        help="Use '--post-command' to post-process key/cert after generation.",
    ),
    post_command: str = typer.Option(
        None,
        "--post-command",
        envvar="POST_COMMAND",
        help="Command to run to post-process cert/key after generation.",
    ),
    cert_type: CertType = typer.Option(
        "server",
        envvar="CERT_TYPE",
        help="Type of certificate to generate.",
    ),
):
    """Create a new certificate signed by the CA key.

    This is compatible with the OpenSSL CA tools, and can read and write "serial"
    and "index.txt" files as used by OpenSSL.

    Various values for the certificate are given by the options marked with "Subject:".
    Options may be specified from the CLI, environment, or config file (in order
    of what overrides, with CLI overriding environment, then config).  See
    "rgca --help" for more information on the config file.

    If --run-pre is set, the command given to --pre-command is run before certificate
    generation is started.  If --run-post is set, the command given to --post-command
    is run after the certificate has been generated.  They are called with these
    environment variables set:

    SCRIPT_TYPE: The string "CERT_NEW".

    FILES: A space separated list of the files generated.

    CERT_FILE: The certificate file.

    KEY_FILE: The key file.
    """

    os.environ["SUBJECT_CN"] = common_name
    os.environ["CERT_FILE"] = cert_file
    os.environ["KEY_FILE"] = key_file
    os.environ["FILES"] = key_file + " " + cert_file

    check_pre_post_args(run_pre, pre_command, run_post, post_command)
    run_pre_script(run_pre, pre_command, {"COMMAND": "CERT_NEW", "STAGE": "PRE"})

    cert_file = Template(cert_file).render(os.environ)
    key_file = Template(key_file).render(os.environ)

    ca_cert = None
    if ca_cert_file:
        with open(ca_cert_file, "rt") as f:
            ca_cert = crypto.load_certificate(
                crypto.FILETYPE_PEM, f.read().encode("ascii")
            )
    if ca_key_file:
        ca_key = load_ca_key(ca_key_file, ca_passphrase)

    cert = crypto.X509()
    cert.set_version(2)
    cert.get_subject().C = country_name
    cert.get_subject().ST = state_name
    cert.get_subject().L = locality_name
    cert.get_subject().O = organization_name  # NOQA: E741
    if organization_unit_name:
        cert.get_subject().OU = organization_unit_name
    cert.get_subject().CN = common_name
    cert.get_subject().emailAddress = email_address

    if append_domain:
        common_name = common_name + append_domain

    san_list = [f"DNS:{common_name}".encode("ascii")]

    if subject_alternative_names:
        for san in subject_alternative_names:
            if append_domain:
                san = san + append_domain
            if not san.startswith("DNS:"):
                san = "DNS:" + san
            san_list.append(san.encode("ascii"))

    certExtensions = []
    if cert_type == "server":
        # certExtensions.append(crypto.X509Extension(b"extendedKeyUsage", True, b"serverAuth"))
        certExtensions.append(crypto.X509Extension(b"nsCertType", False, b"server"))
        certExtensions.append(
            crypto.X509Extension(b"basicConstraints", False, b"CA:FALSE")
        )
        certExtensions.append(
            crypto.X509Extension(
                b"keyUsage",
                False,
                b"Digital Signature, Non Repudiation, Key Encipherment",
            )
        )

    certExtensions.append(
        crypto.X509Extension(b"subjectAltName", False, b", ".join(san_list))
    )

    cert.add_extensions(certExtensions)

    serial_number = get_next_serial(serial_file)
    cert.set_serial_number(serial_number)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(valid_days * 86500)
    if ca_cert:
        cert.set_issuer(ca_cert.get_issuer())

    if index_file:
        cert_not_after = cert.get_notAfter().decode("ascii")[2:]
        cert_dn = str(cert.get_subject()).split("'")[1]
        ca_db_line = f"V\t{cert_not_after}\t\t{serial_number:X}\t{cert_file}\t{cert_dn}\n"

        with index_file.open("a") as fp:
            fp.write(ca_db_line)

    final_passphrase = get_passphrase(
        passphrase, no_passphrase, prompt_for_passphrase, "Cert", confirm=True
    )

    dump_cert_args = {"cipher": cipher, "passphrase": final_passphrase}
    if no_passphrase or not final_passphrase:
        cipher = None
        del dump_cert_args["cipher"]
        del dump_cert_args["passphrase"]

    # create a key pair
    print("Generating key, this may take a moment...")
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)
    cert.set_pubkey(key)

    cert.sign(ca_key, digest)

    with open(cert_file, "wt") as f:
        f.write(crypto.dump_certificate(crypto.FILETYPE_TEXT, cert).decode("ascii"))
        f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode("ascii"))
    with open(key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(crypto.FILETYPE_PEM, key, **dump_cert_args).decode(
                "ascii"
            )
        )

    run_post_script(run_post, post_command, {"COMMAND": "CERT_NEW", "STAGE": "POST"})


if __name__ == "__main__":
    main_app()
