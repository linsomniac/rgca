#!/usr/bin/env python3

from typing import Optional, List, Union, Generator
from enum import Enum
from OpenSSL import crypto, SSL
from pathlib import Path
import os
from configparser import ConfigParser
import subprocess
import shlex
import datetime
import re
import typer
import click
from jinja2 import Template

main_app = typer.Typer()
ca_app = typer.Typer()
cert_app = typer.Typer()
crl_app = typer.Typer()
main_app.add_typer(ca_app, name="ca", help="Certificate Authority")
main_app.add_typer(cert_app, name="cert", help="Certificate")
main_app.add_typer(crl_app, name="crl", help="Certificate Revocation List")


class SerialBits(str, Enum):
    bits32 = "32"
    bits64 = "64"
    bits128 = "128"


class MessageDigest(str, Enum):
    sha256 = "sha256"
    sha512 = "sha512"


class CertType(str, Enum):
    server = "server"


class CertStatus(str, Enum):
    valid = "V"
    revoked = "R"
    expired = "E"


class Cipher(str, Enum):
    des3 = "des3"
    aes128 = "aes128"
    aes192 = "aes192"
    aes256 = "aes256"


class RevokedReasons(str, Enum):
    unspecified = "unspecified"
    keyCompromise = "keyCompromise"
    CACompromise = "CACompromise"
    affiliationChanged = "affiliationChanged"
    superseded = "superseded"
    cessationOfOperation = "cessationOfOperation"
    certificateHold = "certificateHold"


class IndexFile:
    def __init__(self, index_filename):
        self.index_filename = index_filename
        self.load()

    def load(self):
        rx = re.compile(
            r"^(?P<status>[VRE])\s+(?P<expiration_date>\d+Z)\s+"
            r"(?P<revocation_date>(?:\d+Z)|)\s(?P<serial_number>[\dabcdefABCDEF]+)\s+"
            r"(?P<filename>\S+)\s+(?P<cert_dn>\S+)\s*$"
        )
        with open(self.index_filename, "rt") as f:
            self.index_data = []
            line_number = 0
            for line in f.readlines():
                line_number += 1
                match = rx.match(line)
                if not match:
                    typer.echo(
                        f"ERROR: Unable to parse index line {line_number} in {self.index_filename}"
                    )
                    continue
                self.index_data.append(match.groupdict())

    def parse_dn(self, dn: str) -> dict:
        parsed = {}
        for x in dn.split("/"):
            if not x:
                continue
            name, value = x.split("=", 1)
            parsed[name] = value
        return parsed

    def get_by_common_name(self, cn: str) -> Generator[dict, None, None]:
        for row in self.index_data:
            if self.parse_dn(row["cert_dn"]).get("CN") == cn:
                yield row

    def set_sn_status(self, sn: str, status: CertStatus) -> None:
        sn = sn.lstrip("0")

        for row in self.index_data:
            if row["serial_number"].lstrip("0") == sn:
                row["status"] = status

    def write(self) -> None:
        tmp_file = os.fspath(self.index_filename) + ".tmp"
        with open(tmp_file, "wt") as f:
            for row in self.index_data:
                f.write(
                    f"{row['status']}\t"
                    f"{row['expiration_date']}\t"
                    f"{row['revocation_date']}\t"
                    f"{row['serial_number']}\t"
                    f"{row['filename']}\t"
                    f"{row['cert_dn']}\n"
                )
            os.rename(tmp_file, self.index_filename)


@main_app.callback()
def callback(
    ctx: typer.Context,
    config: Optional[List[Path]] = typer.Option(
        [".rgca.ini", os.path.expanduser("~/.config/rgca/config.ini")],
        envvar="CONFIG",
        help="Ini format config file",
        dir_okay=False,
        exists=False,
        readable=True,
    ),
    config_group: str = typer.Option(
        "DEFAULT",
        "--config-group",
        "--group",
        "-G",
        envvar="CONFIG_GROUP",
        help="Additional group to pull settings from.  If set, named group in the "
        "config file will be loaded in addition to 'DEFAULT'.",
    ),
):
    """rgca is a Certificate Authority helper, to make creating certificates, either from scripts
    or from the CLI, easier.  All (reasonable) values can be passed either by CLI arguments, config
    files, or the environment.  See the help for the sub commands for more information, but an example
    use could be:

        rgca cert new www.example.com

    The above command is incomplete, as it doesn't specify various Subject items like Country, Locality,
    Organization, etc...  But if you run the above, it will tell you what is missing.  A more complete
    run might look like:

        rgca cert new --C US --ST Colorado --L Denver --O Example -E user@example.com www.example.com

    Or, if you specify subject items in a config file:

        rgca --config config.ini cert new www.example.com www.crt www.key

    It is compatible with OpenSSL commands (including managing the "serial" and "index.txt" files).

    One or more config files may be specified in "INI" format.  Earlier config files override
    values set in later files. There is a "DEFAULT" group that is always read, and other sections
    may be selected using the "--config-group" option, so that multiple configurations may be
    easliy switched between.

    Normally, config values will not override those in the environment or from earlier config
    files or sections.  The the name starts with "!", it will override the environment or earlier
    config files/sections.

    Values may also be set using the environment.  Options that can be set from the environment are
    listed in the help related to those options.

    For example, take this "config.ini":

        [DEFAULT]
        SUBJECT_C=US
        SUBJECT_ST=Colorado
        SUBJECT_L=Denver
        SUBJECT_O=Example
        SUBJECT_OU=Corporate
        SUBJECT_EMAIL=admin@example.com

        [widget]
        SUBJECT_OU=Widgets
        SUBJECT_EMAIL=admin@widgets.example.com

    Then you can run it with:

        rgca --config config.ini cert new www.example.com www.crt www.key
        rgca --config config.ini --config-group widget cert new widgets.example.com widgets.crt widgets.key
    """
    if not config:
        return

    for config_file in config:
        if config_file.exists():
            ini = ConfigParser()
            ini.read_string(config_file.read_text())

            for k, v in ini[config_group].items():
                envname = k.upper()
                if envname not in os.environ:
                    os.environ[envname] = v
                if envname.startswith("!"):
                    os.environ[envname[1:]] = v


def revoke(
    crl: crypto.CRL,
    sn: bytes,
    rev_date: Union[str, None],
    reason: Union[RevokedReasons, None],
    index: Union[IndexFile, None],
) -> None:
    """Add the serial number to the CRL."""
    revoked = crypto.Revoked()
    revoked.set_serial(sn)
    revoked.set_rev_date(encode_rev_date(rev_date))
    revoked.set_reason(encode_reason(reason))
    crl.add_revoked(revoked)


def asn1_now() -> bytes:
    """Return the current time as an ASN.1 string"""
    return datetime.datetime.utcnow().strftime("%Y%m%d%H%M%SZ").encode("ascii")


def encode_rev_date(rev_date: Union[None, str]) -> bytes:
    """Convert revocation date for passing to Revoke object."""
    if rev_date is None:
        return asn1_now()
    return rev_date.encode("ascii")


def encode_reason(reason: Union[RevokedReasons, None]) -> Union[None, bytes]:
    """Convert RevokedReasons for passing to Revoke object."""
    if reason is None:
        return None
    return reason.encode("ascii")


def index_serial_number(serial_number: int) -> str:
    """Format the serial number for the index file."""
    s = format(serial_number, "X")
    if len(s) % 2 == 1:
        s = "0" + s
    return s


def get_key_encrypt_args(
    passphrase: Union[str, None],
    no_passphrase: bool,
    prompt_for_passphrase: bool,
    cipher: Union[Cipher, None],
    key_type: str,
    confirm: bool = False,
) -> dict:
    """Given CLI arguments, create the arguments to pass to the key dump function for encryption.

    Args:
        passphrase:             Argument from CLI.
        no_passphrase:          Argument from CLI.
        prompt_for_passphrase:  Argument from CLI.
        cipher:                 Argument from CLI, if None, no "cipher" is in returned dict.
        key_type:               Description of key to use when prompting.
        confirm:                Whether to ask the user to verify the passphrase.

    Returns:
        Arguments to pass to the cert dump function for encryption settings."""
    args = {"passphrase": passphrase}
    if cipher:
        args["cipher"] = cipher

    if no_passphrase:
        return {}
    if prompt_for_passphrase or passphrase is None:
        args["passphrase"] = click.prompt(
            f"{key_type} Passphrase", hide_input=True, confirmation_prompt=confirm
        )
    if type(args["passphrase"]) is str:
        args["passphrase"] = args["passphrase"].encode("ascii")
    if not args["passphrase"]:
        return {}

    return args


@ca_app.command(name="new")
def ca_new(
    common_name: str = typer.Argument(
        ..., envvar="SUBJECT_CN", help="Main name on certificate"
    ),
    ca_key_file: str = typer.Argument(
        ..., envvar="CA_KEY_FILE", help="File name to write private key to."
    ),
    ca_cert_file: str = typer.Argument(
        ..., envvar="CA_CERT_FILE", help="File name to write CA certificate to."
    ),
    bits: int = typer.Option(
        8192,
        "--ca-key-bits",
        "--bits",
        "-b",
        envvar="CA_KEY_BITS",
        help="Size of generated key, in bits.",
    ),
    cipher: Cipher = typer.Option(
        Cipher.aes256,
        "--cipher",
        "-c",
        envvar="CA_CIPHER",
        help="Cipher to use to encrypt CA key.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        envvar="CA_PASSPHRASE",
        help="Passphrase for CA key",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "--no-passphrase",
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
    overwrite: bool = typer.Option(
        False, help="Overwrite the key file if it already exists."
    ),
    valid_days: int = typer.Option(
        365,
        "--valid-days",
        "-d",
        envvar="VALID_DAYS",
        help="Number of days the certificate is valid for.",
    ),
    digest: MessageDigest = typer.Option(
        "sha512",
        "--digest",
        "-D",
        envvar="DIGEST",
        help="Message digest to use when signing the key.",
    ),
    append_domain: Optional[str] = typer.Option(
        None,
        "--append-domain",
        "-a",
        envvar="APPEND_DOMAIN",
        help="If provided, this value is appended to all domain names (CN, SAN) so "
        "short names can be used.  For example this creates ca.example.com "
        "rgca ca new --append-domain .example.com ca ca.crt ca.key",
    ),
    country_name: str = typer.Option(
        ...,
        "--country-name",
        "--C",
        "-C",
        envvar="SUBJECT_C",
        help="Subject: Country name",
    ),
    state_name: str = typer.Option(
        ...,
        "--state-name",
        "--ST",
        "-ST",
        envvar="SUBJECT_ST",
        help="Subject: State name",
    ),
    locality_name: str = typer.Option(
        ...,
        "--locality-name",
        "--L",
        "-L",
        envvar="SUBJECT_L",
        help="Subject: Locality(city) name",
    ),
    organization_name: str = typer.Option(
        ...,
        "--organization-name",
        "--O",
        "-O",
        envvar="SUBJECT_O",
        help="Subject: Organization name",
    ),
    organization_unit_name: Optional[str] = typer.Option(
        None,
        "--organization-unit-name",
        "--OU",
        "-OU",
        envvar="SUBJECT_OU",
        help="Subject: Organization unit name",
    ),
    email_address: str = typer.Option(
        ...,
        "--email-address",
        "--E",
        "-E",
        envvar="SUBJECT_EMAIL",
        help="Subject: Email address",
    ),
    run_pre: bool = typer.Option(
        False,
        envvar="RUN_PRE",
        help="Use '--pre-command' before certificate generation.",
    ),
    pre_command: str = typer.Option(
        None,
        "--pre-command",
        envvar="PRE_COMMAND",
        help="Command to run to before starting certificate generation.",
    ),
    run_post: bool = typer.Option(
        False,
        envvar="RUN_POST",
        help="Use '--post-command' to post-process key/cert after generation.",
    ),
    post_command: str = typer.Option(
        None,
        "--post-command",
        envvar="POST_COMMAND",
        help="Command to run to post-process cert/key after generation.",
    ),
    random_serial_bits: SerialBits = typer.Option(
        "64",
        envvar="RANDOM_SERIAL_BITS",
        help="Number of bits for the random serial number generation.",
    ),
):
    """Create a new Certificate Authority"""
    if not overwrite and (os.path.exists(ca_key_file) or os.path.exists(ca_cert_file)):
        typer.echo(
            'Key or Cert file already exists, will not overwrite without "--overwrite" option.'
        )
        raise typer.Exit(code=1)

    if append_domain:
        common_name = common_name + append_domain
    os.environ["SUBJECT_CN"] = common_name
    ca_cert_file = Template(ca_cert_file).render(os.environ)
    ca_key_file = Template(ca_key_file).render(os.environ)
    os.environ["CA_CERT_FILE"] = ca_cert_file
    os.environ["CA_KEY_FILE"] = ca_key_file
    os.environ["FILES"] = ca_key_file + " " + ca_cert_file

    check_pre_post_args(run_pre, pre_command, run_post, post_command)
    run_pre_script(run_pre, pre_command, {"COMMAND": "CA_NEW", "STAGE": "PRE"})

    key_crypt_args = get_key_encrypt_args(
        passphrase, no_passphrase, prompt_for_passphrase, cipher, "CA", confirm=True
    )

    ca_cert = crypto.X509()
    ca_cert.set_version(2)
    ca_cert.get_subject().C = country_name
    ca_cert.get_subject().ST = state_name
    ca_cert.get_subject().L = locality_name
    ca_cert.get_subject().O = organization_name  # NOQA: E741
    if organization_unit_name:
        ca_cert.get_subject().OU = organization_unit_name
    ca_cert.get_subject().CN = common_name
    ca_cert.get_subject().emailAddress = email_address
    ca_cert.set_issuer(ca_cert.get_subject())

    ca_cert.add_extensions(
        [
            crypto.X509Extension(b"basicConstraints", False, b"CA:TRUE"),
        ]
    )

    serial_number = int.from_bytes(os.urandom(int(random_serial_bits) // 8), "big")
    ca_cert.set_serial_number(serial_number)
    ca_cert.gmtime_adj_notBefore(0)
    ca_cert.gmtime_adj_notAfter(valid_days * 86500)

    print("Generating key, this may take a moment...")
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)
    ca_cert.set_pubkey(key)
    ca_cert.sign(key, digest)

    with open(ca_cert_file, "wt") as f:
        f.write(crypto.dump_certificate(crypto.FILETYPE_TEXT, ca_cert).decode("ascii"))
        f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, ca_cert).decode("ascii"))
    with open(ca_key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(crypto.FILETYPE_PEM, key, **key_crypt_args).decode(
                "ascii"
            )
        )

    run_post_script(run_post, post_command, {"COMMAND": "CA_NEW", "STAGE": "POST"})


@main_app.command(name="showkey")
def main_showkey(
    key_file: str = typer.Argument(
        ..., envvar="KEY_FILE", help="Key file to show information about."
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.",
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        "--prompt-for-passphrase",
        "-P",
        envvar="PASSPHRASE",
        help="Passphrase for key",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "--no-passphrase",
        "-N",
        help="Do not put a passphrase on the key file.",
    ),
):
    """Display information about the key in a keyfile."""

    key_crypt_args = get_key_encrypt_args(
        passphrase, no_passphrase, prompt_for_passphrase, None, "Keyfile", confirm=False
    )

    with open(key_file, "rt") as f:
        try:
            key = crypto.load_privatekey(crypto.FILETYPE_PEM, f.read(), **key_crypt_args)
        except crypto.Error as e:
            error = " ".join(e.args[0][0])
            typer.echo(f"Failed to load key: {error}")
            raise typer.Exit(code=1)

    type_name = str(key.type())
    if key.type() == crypto.TYPE_RSA:
        type_name = "RSA"
    if key.type() == crypto.TYPE_DSA:
        type_name = "DSA"

    print(f"Bits: {key.bits()}  Type: {type_name}")


def get_next_serial(path: Path) -> int:
    """Load the next serial number from `path`.

    Args:
        path: File containing the next serial number in hex representation.

    Returns:
        The next serial number as integer.
    """
    if not path:
        return 0

    if not path.exists():
        with path.open("w") as fp:
            fp.write("1\n")
        return 0

    with path.open("r") as fp:
        next_serial = int(fp.readline().strip(), 16)
    with path.open("w") as fp:
        fp.write(f"{next_serial+1:X}\n")
    return next_serial


def run_script(script_command: str, env: dict) -> int:
    """Run the pre/post script command to deliver keys.

    Args:
        - script_command: Command to pre/post processes.  This is parsed with shlex.split().
        - env: Environment values set before running.

    Returns:
        0 on success, process exit code on failure.
    """
    merged_env = os.environ.copy()
    merged_env.update(env)
    try:
        subprocess.run(shlex.split(script_command), check=True, env=merged_env)
        return 0
    except subprocess.CalledProcessError as e:
        return e.returncode


def check_pre_post_args(
    run_pre: bool, pre_command: str, run_post: bool, post_command: str
) -> None:
    """Check the pre and post arguments to make sure they are valid."""
    if run_pre and pre_command is None:
        typer.echo(
            "If run with '--run-pre', a '--pre-command' must be specified (can "
            "also be via environment or config PRE_COMMAND)."
        )
        raise typer.Exit(1)
    if run_post and post_command is None:
        typer.echo(
            "If run with '--run-post', a '--post-command' must be specified (can "
            "also be via environment or config POST_COMMAND)."
        )
        raise typer.Exit(1)


def run_pre_script(run_pre: bool, pre_command: str, add_env: dict = {}) -> None:
    """Run the pre script if arguments specify it.

    Args:
        run_pre: Should the pre script be run.
        pre_command: The command that specifies the pre script.
        add_env: Environment values to be set for command run.
    """

    if run_pre:
        retval = run_script(os.path.expanduser(pre_command), add_env)
        if retval != 0:
            typer.echo(f"Pre command failed, returned {retval} instead of 0")
            raise typer.Exit(1)


def run_post_script(run_post: bool, post_command: str, add_env: dict = {}) -> None:
    """Run the post script if arguments specify it.

    Args:
        run_post: Should the post script be run.
        post_command: The command that specifies the post script.
        add_env: Environment values to be set for command run.
    """
    if run_post:
        retval = run_script(os.path.expanduser(post_command), add_env)
        if retval != 0:
            typer.echo(f"Post command failed, returned {retval} instead of 0")
            raise typer.Exit(1)


def load_ca_key(ca_key_file: str, ca_passphrase: Union[str, None]) -> crypto.PKey:
    """Load the CA private key, asking for passphrase if necessary.

    Returns:
        The key that was loaded."""
    with open(ca_key_file, "rt") as f:
        capass = ca_passphrase

        def askcapass(_) -> bytes:
            return click.prompt("CA Passphrase to sign key", hide_input=True).encode(
                "ascii"
            )

        if ca_passphrase is None:
            capass = askcapass
        if type(capass) is str:
            capass = capass.encode("ascii")

        try:
            return crypto.load_privatekey(
                crypto.FILETYPE_PEM, f.read(), passphrase=capass
            )
        except crypto.Error as e:
            error = " ".join(e.args[0][0])
            typer.echo(f"Failed to load CA key: {error}")
            raise typer.Exit(code=1)


def load_ca_key_args(ca_key_file: str, key_crypt_args: dict) -> crypto.PKey:
    """Load the CA private key, using args based on get_key_encrypt_args()

    Returns:
        The key that was loaded."""
    with open(ca_key_file, "rt") as f:
        try:
            return crypto.load_privatekey(crypto.FILETYPE_PEM, f.read(), **key_crypt_args)
        except crypto.Error as e:
            error = " ".join(e.args[0][0])
            typer.echo(f"Failed to load CA key: {error}")
            raise typer.Exit(code=1)


@cert_app.command(name="new")
def cert_new(
    common_name: str = typer.Argument(
        ..., envvar="SUBJECT_CN", help="Main name on certificate"
    ),
    cert_file: str = typer.Option(
        "{{ SUBJECT_CN }}.crt",
        envvar="CERT_FILE",
        help="File name to write certificate to.  This name can be "
        "jinja2 templated from the environment.",
    ),
    key_file: str = typer.Option(
        "{{ SUBJECT_CN }}.key",
        envvar="KEY_FILE",
        help="File name to write private key to.  This name can be "
        "jinja2 templated from the environment.",
    ),
    serial_file: Path = typer.Option(
        None,
        envvar="SERIAL_FILE",
        help="File that has the next serial number in it.  "
        "If undefined or a non-existant file, serial 0 is used.",
    ),
    random_serial: bool = typer.Option(
        True,
        envvar="RANDOM_SERIAL",
        help="Use a randomly generated serial number rather than the --serial-file.",
    ),
    random_serial_bits: SerialBits = typer.Option(
        "64",
        envvar="RANDOM_SERIAL_BITS",
        help="Number of bits for the random serial number generation.",
    ),
    index_file: Path = typer.Option(
        None,
        envvar="INDEX_FILE",
        help="File to write the certificate information to (ca database).",
    ),
    valid_days: int = typer.Option(
        365,
        "--valid-days",
        "-d",
        envvar="VALID_DAYS",
        help="Number of days the certificate is valid for.",
    ),
    subject_alternative_names: Optional[List[str]] = typer.Option(
        None,
        "--san",
        "-s",
        help="Subject alternative name to add to the certificate.  The Common Name is "
        "listed as the first SAN.",
    ),
    bits: int = typer.Option(
        8192,
        "--bits",
        "-b",
        envvar="BITS",
        help="Size of generated key, in bits.",
    ),
    digest: MessageDigest = typer.Option(
        "sha512",
        "--digest",
        "-D",
        envvar="DIGEST",
        help="Message digest to use when signing the key.",
    ),
    append_domain: Optional[str] = typer.Option(
        None,
        "--append-domain",
        "-a",
        envvar="APPEND_DOMAIN",
        help="If provided, this value is appended to all domain names (CN, SAN) so "
        "short names can be used.  For example this creates a web.example.com "
        "cert without having to repeat '.example.com' all over: rgca cert new "
        "--append-domain .example.com --san test --san foo web web.crt web.key",
    ),
    country_name: str = typer.Option(
        ...,
        "--country-name",
        "--C",
        "-C",
        envvar="SUBJECT_C",
        help="Subject: Country name",
    ),
    state_name: str = typer.Option(
        ...,
        "--state-name",
        "--ST",
        "-ST",
        envvar="SUBJECT_ST",
        help="Subject: State name",
    ),
    locality_name: str = typer.Option(
        ...,
        "--locality-name",
        "--L",
        "-L",
        envvar="SUBJECT_L",
        help="Subject: Locality(city) name",
    ),
    organization_name: str = typer.Option(
        ...,
        "--organization-name",
        "--O",
        "-O",
        envvar="SUBJECT_O",
        help="Subject: Organization name",
    ),
    organization_unit_name: Optional[str] = typer.Option(
        None,
        "--organization-unit-name",
        "--OU",
        "-OU",
        envvar="SUBJECT_OU",
        help="Subject: Organization unit name",
    ),
    email_address: str = typer.Option(
        ...,
        "--email-address",
        "--E",
        "-E",
        envvar="SUBJECT_EMAIL",
        help="Subject: Email address",
    ),
    cipher: Cipher = typer.Option(
        Cipher.aes256,
        "--cipher",
        "-c",
        envvar="CERT_CIPHER",
        help="Cipher to use to encrypt certificate key.  This is only used if a "
        "passphrase is specified.",
    ),
    ca_cert_file: str = typer.Option(
        ...,
        envvar="CA_CERT_FILE",
        help="File name of the CA certificate, if specified the "
        "generated cert is issued using this certificate.  This needs to be specified "
        "to properly be marked as being issued by the CA.",
    ),
    ca_key_file: str = typer.Option(
        ...,
        envvar="CA_KEY_FILE",
        help="File name of the CA key, if specified the "
        "generated cert is signed with this key.  If not specified, the cert "
        "is unsigned.",
    ),
    ca_passphrase: Union[str, None] = typer.Option(
        None,
        "--ca-passphrase",
        envvar="CA_PASSPHRASE",
        help="Passphrase to decrypt the key.  If not specified, and the key is "
        "encrypted, a passphrase will be prompted for.",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase, overriding the config or environment settings.  "
        "Is overridden by --no-passphrase.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "--no-passphrase",
        "-N",
        envvar="NO_PASSPHRASE",
        help="Do not put a passphrase on the key file.  This overrides settings in the "
        "config/environment/CLI for --passphrase/--prompt-for-passphrase.",
    ),
    run_pre: bool = typer.Option(
        False,
        envvar="RUN_PRE",
        help="Use '--pre-command' before certificate generation.",
    ),
    pre_command: str = typer.Option(
        None,
        "--pre-command",
        envvar="PRE_COMMAND",
        help="Command to run to before starting certificate generation.",
    ),
    run_post: bool = typer.Option(
        False,
        envvar="RUN_POST",
        help="Use '--post-command' to post-process key/cert after generation.",
    ),
    post_command: str = typer.Option(
        None,
        "--post-command",
        envvar="POST_COMMAND",
        help="Command to run to post-process cert/key after generation.",
    ),
    cert_type: CertType = typer.Option(
        "server",
        envvar="CERT_TYPE",
        help="Type of certificate to generate.",
    ),
):
    """Create a new certificate signed by the CA key.

    This is compatible with the OpenSSL CA tools, and can read and write "serial"
    and "index.txt" files as used by OpenSSL.

    Various values for the certificate are given by the options marked with "Subject:".
    Options may be specified from the CLI, environment, or config file (in order
    of what overrides, with CLI overriding environment, then config).  See
    "rgca --help" for more information on the config file.

    If --run-pre is set, the command given to --pre-command is run before certificate
    generation is started.  If --run-post is set, the command given to --post-command
    is run after the certificate has been generated.  They are called with these
    environment variables set:

    SCRIPT_TYPE: The string "CERT_NEW".

    FILES: A space separated list of the files generated.

    CERT_FILE: The certificate file.

    KEY_FILE: The key file.
    """
    if append_domain:
        common_name = common_name + append_domain
    os.environ["SUBJECT_CN"] = common_name
    cert_file = Template(cert_file).render(os.environ)
    key_file = Template(key_file).render(os.environ)
    os.environ["CERT_FILE"] = cert_file
    os.environ["KEY_FILE"] = key_file
    os.environ["FILES"] = key_file + " " + cert_file

    check_pre_post_args(run_pre, pre_command, run_post, post_command)
    run_pre_script(run_pre, pre_command, {"COMMAND": "CERT_NEW", "STAGE": "PRE"})

    ca_cert = None
    if ca_cert_file:
        with open(ca_cert_file, "rt") as f:
            ca_cert = crypto.load_certificate(
                crypto.FILETYPE_PEM, f.read().encode("ascii")
            )
    if ca_key_file:
        ca_key = load_ca_key(ca_key_file, ca_passphrase)

    cert = crypto.X509()
    cert.set_version(2)
    cert.get_subject().C = country_name
    cert.get_subject().ST = state_name
    cert.get_subject().L = locality_name
    cert.get_subject().O = organization_name  # NOQA: E741
    if organization_unit_name:
        cert.get_subject().OU = organization_unit_name
    cert.get_subject().CN = common_name
    cert.get_subject().emailAddress = email_address

    san_list = [f"DNS:{common_name}".encode("ascii")]

    if subject_alternative_names:
        for san in subject_alternative_names:
            if append_domain:
                san = san + append_domain
            if not san.startswith("DNS:"):
                san = "DNS:" + san
            san_list.append(san.encode("ascii"))

    certExtensions = []
    if cert_type == "server":
        # certExtensions.append(crypto.X509Extension(b"extendedKeyUsage", True, b"serverAuth"))
        certExtensions.append(crypto.X509Extension(b"nsCertType", False, b"server"))
        certExtensions.append(
            crypto.X509Extension(b"basicConstraints", False, b"CA:FALSE")
        )
        certExtensions.append(
            crypto.X509Extension(
                b"keyUsage",
                False,
                b"Digital Signature, Non Repudiation, Key Encipherment",
            )
        )

    certExtensions.append(
        crypto.X509Extension(b"subjectAltName", False, b", ".join(san_list))
    )

    cert.add_extensions(certExtensions)

    if random_serial:
        serial_number = int.from_bytes(os.urandom(int(random_serial_bits) // 8), "big")
    else:
        serial_number = get_next_serial(serial_file)

    cert.set_serial_number(serial_number)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(valid_days * 86500)
    if ca_cert:
        cert.set_issuer(ca_cert.get_issuer())

    if index_file:
        cert_not_after = cert.get_notAfter().decode("ascii")[2:]
        cert_dn = str(cert.get_subject()).split("'")[1]
        ca_db_line = f"V\t{cert_not_after}\t\t{index_serial_number(serial_number)}\t{cert_file}\t{cert_dn}\n"

        with index_file.open("a") as fp:
            fp.write(ca_db_line)

    key_crypt_args = get_key_encrypt_args(
        ca_passphrase, no_passphrase, prompt_for_passphrase, cipher, "Cert", confirm=True
    )

    # create a key pair
    print("Generating key, this may take a moment...")
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, bits)
    cert.set_pubkey(key)

    cert.sign(ca_key, digest)

    with open(cert_file, "wt") as f:
        f.write(crypto.dump_certificate(crypto.FILETYPE_TEXT, cert).decode("ascii"))
        f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode("ascii"))
    with open(key_file, "wt") as f:
        f.write(
            crypto.dump_privatekey(crypto.FILETYPE_PEM, key, **key_crypt_args).decode(
                "ascii"
            )
        )

    run_post_script(run_post, post_command, {"COMMAND": "CERT_NEW", "STAGE": "POST"})


@cert_app.command(name="show")
def cert_show(
    cert_file: typer.FileText = typer.Argument(
        ..., envvar="CERT_FILE", help="Certificate file to show information about."
    ),
):
    """Display information about a certificate."""

    cert = crypto.load_certificate(crypto.FILETYPE_PEM, cert_file.read().encode("ascii"))
    print(crypto.dump_certificate(crypto.FILETYPE_TEXT, cert).decode("ascii"))


@crl_app.command(name="new")
def crl_new(
    crl_file: str = typer.Argument(
        ..., envvar="CRL_FILE", help="Certificate Revocation List file."
    ),
    ca_key_file: str = typer.Argument(
        ..., envvar="CA_KEY_FILE", help="File name to write private key to."
    ),
    ca_cert_file: str = typer.Argument(
        ..., envvar="CA_CERT_FILE", help="File name to write CA certificate to."
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        envvar="CA_PASSPHRASE",
        help="Passphrase for CA key",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase for the CA key, overriding the config or environment settings.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "--no-passphrase",
        "-N",
        help="Do not use a passphrase for the CA key.",
    ),
    valid_days: int = typer.Option(
        100,
        "--valid-days",
        "-d",
        envvar="CRL_VALID_DAYS",
        help="Number of days the CRL is valid for.",
    ),
    digest: MessageDigest = typer.Option(
        "sha512",
        "--digest",
        "-D",
        envvar="DIGEST",
        help="Message digest to use when signing the key.",
    ),
    overwrite: bool = typer.Option(
        False, help="Overwrite the key file if it already exists."
    ),
    index_file: Path = typer.Option(
        None,
        envvar="INDEX_FILE",
        help="File to write the certificate information to (ca database).",
    ),
    run_pre: bool = typer.Option(
        False,
        envvar="RUN_PRE",
        help="Use '--pre-command' before certificate generation.",
    ),
    pre_command: str = typer.Option(
        None,
        "--pre-command",
        envvar="PRE_COMMAND",
        help="Command to run to before starting certificate generation.",
    ),
    run_post: bool = typer.Option(
        False,
        envvar="RUN_POST",
        help="Use '--post-command' to post-process key/cert after generation.",
    ),
    post_command: str = typer.Option(
        None,
        "--post-command",
        envvar="POST_COMMAND",
        help="Command to run to post-process cert/key after generation.",
    ),
):
    """Create a new Certificate Revocation List"""
    crl_file = Template(crl_file).render(os.environ)
    ca_key_file = Template(ca_key_file).render(os.environ)
    ca_cert_file = Template(ca_cert_file).render(os.environ)
    os.environ["CRL_FILE"] = crl_file
    os.environ["FILES"] = crl_file

    if not overwrite and os.path.exists(crl_file):
        typer.echo(
            'CRL file already exists, will not overwrite without "--overwrite" option.'
        )
        raise typer.Exit(code=1)

    check_pre_post_args(run_pre, pre_command, run_post, post_command)
    run_pre_script(run_pre, pre_command, {"COMMAND": "CRL_NEW", "STAGE": "PRE"})

    key_crypt_args = get_key_encrypt_args(
        passphrase, no_passphrase, prompt_for_passphrase, None, "CA", confirm=False
    )
    ca_key = load_ca_key_args(ca_key_file, key_crypt_args)

    with open(ca_cert_file, "rt") as f:
        ca_cert = crypto.load_certificate(crypto.FILETYPE_PEM, f.read().encode("ascii"))

    crl = crypto.CRL()
    crl_text = crl.export(
        ca_cert, ca_key, crypto.FILETYPE_TEXT, valid_days, digest.encode("ascii")
    )
    crl_pem = crl.export(
        ca_cert, ca_key, crypto.FILETYPE_PEM, valid_days, digest.encode("ascii")
    )

    with open(crl_file, "wt") as f:
        f.write(crl_text.decode("ascii"))
        f.write(crl_pem.decode("ascii"))

    run_post_script(run_post, post_command, {"COMMAND": "CRL_NEW", "STAGE": "POST"})


@crl_app.command(name="revoke")
def crl_revoke(
    serial: Optional[List[str]] = typer.Option(
        None,
        "--serial",
        "-s",
        help="The serial number of a certificate to revoke.",
    ),
    cert_file: Optional[List[typer.FileText]] = typer.Option(
        None,
        "--cert-file",
        "-f",
        help="Certificate file to revoke.",
    ),
    common_name: Optional[List[str]] = typer.Option(
        None,
        "--common-name",
        "-n",
        help="Certificate file to revoke.",
    ),
    reason: Optional[RevokedReasons] = typer.Option(
        None,
        "--reason",
        "-r",
        help="Reason the keys are being revoked.",
    ),
    rev_date: Optional[str] = typer.Option(
        None,
        help="ASN.1 formatted revocation date (defaults to current time, format: [YYYYMMDDHHMMSS]Z).",
    ),
    crl_file: str = typer.Argument(
        ..., envvar="CRL_FILE", help="Certificate Revocation List file."
    ),
    ca_key_file: str = typer.Argument(
        ..., envvar="CA_KEY_FILE", help="File name to write private key to."
    ),
    ca_cert_file: str = typer.Argument(
        ..., envvar="CA_CERT_FILE", help="File name to write CA certificate to."
    ),
    passphrase: Union[str, None] = typer.Option(
        None,
        envvar="CA_PASSPHRASE",
        help="Passphrase for CA key",
    ),
    prompt_for_passphrase: bool = typer.Option(
        False,
        "--prompt-for-passphrase",
        "-P",
        help="Prompt for a passphrase for the CA key, overriding the config or environment settings.",
    ),
    no_passphrase: bool = typer.Option(
        False,
        "--no-passphrase",
        "-N",
        help="Do not use a passphrase for the CA key.",
    ),
    valid_days: int = typer.Option(
        100,
        "--valid-days",
        "-d",
        envvar="CRL_VALID_DAYS",
        help="Number of days the CRL is valid for.",
    ),
    digest: MessageDigest = typer.Option(
        "sha512",
        "--digest",
        "-D",
        envvar="DIGEST",
        help="Message digest to use when signing the key.",
    ),
    index_file: Path = typer.Option(
        None,
        envvar="INDEX_FILE",
        help="File to write the certificate information to (ca database).",
    ),
    run_pre: bool = typer.Option(
        False,
        envvar="RUN_PRE",
        help="Use '--pre-command' before certificate generation.",
    ),
    pre_command: str = typer.Option(
        None,
        "--pre-command",
        envvar="PRE_COMMAND",
        help="Command to run to before starting certificate generation.",
    ),
    run_post: bool = typer.Option(
        False,
        envvar="RUN_POST",
        help="Use '--post-command' to post-process key/cert after generation.",
    ),
    post_command: str = typer.Option(
        None,
        "--post-command",
        envvar="POST_COMMAND",
        help="Command to run to post-process cert/key after generation.",
    ),
):
    """Revoke certificates"""
    crl_file = Template(crl_file).render(os.environ)
    ca_key_file = Template(ca_key_file).render(os.environ)
    ca_cert_file = Template(ca_cert_file).render(os.environ)
    os.environ["CRL_FILE"] = crl_file
    os.environ["FILES"] = crl_file

    if common_name and not index_file:
        typer.echo("--common-name requires --index-file")
        raise typer.Exit(code=1)

    check_pre_post_args(run_pre, pre_command, run_post, post_command)
    run_pre_script(run_pre, pre_command, {"COMMAND": "CRL_REVOKE", "STAGE": "PRE"})

    key_crypt_args = get_key_encrypt_args(
        passphrase, no_passphrase, prompt_for_passphrase, None, "CA", confirm=False
    )
    ca_key = load_ca_key_args(ca_key_file, key_crypt_args)

    with open(ca_cert_file, "rt") as f:
        ca_cert = crypto.load_certificate(crypto.FILETYPE_PEM, f.read().encode("ascii"))

    with open(crl_file, "rt") as f:
        crl = crypto.load_crl(crypto.FILETYPE_PEM, f.read().encode("ascii"))

    existing_serials = list(
        [int(x.get_serial().decode("ascii"), 16) for x in crl.get_revoked()]
    )
    updates = 0

    index = None
    if index_file:
        index = IndexFile(index_file)

    if serial:
        for sn in serial:
            if index:
                index.set_sn_status(sn.encode("ascii"), CertStatus.revoked)
            if int(sn, 16) in existing_serials:
                typer.echo(f"Serial '{sn}' already in CRL, skipping...")
                continue
            revoke(crl, sn.encode("ascii"), rev_date, reason, index)
            updates += 1

    if cert_file:
        for x in cert_file:
            cert = crypto.load_certificate(crypto.FILETYPE_PEM, x.read().encode("ascii"))
            sn = cert.get_serial_number()

            if index:
                index.set_sn_status(f"{sn:X}", CertStatus.revoked)
            if sn in existing_serials:
                typer.echo(f"Serial '{sn}' ({x.name}) already in CRL, skipping...")
                continue
            revoke(crl, f"{sn:X}".encode("ascii"), rev_date, reason, index)
            updates += 1

    if common_name:
        for cn in common_name:
            for cert_info in index.get_by_common_name(cn):
                sn = int(cert_info["serial_number"], 16)
                if index:
                    index.set_sn_status(f"{sn:X}", CertStatus.revoked)
                if sn in existing_serials:
                    typer.echo(f"Serial '{sn}' already in CRL, skipping...")
                    continue
                revoke(crl, f"{sn:X}".encode("ascii"), rev_date, reason, index)
                updates += 1

    if index:
        index.write()

    if updates == 0:
        typer.echo("No updates were done to CRL, skipping update.")
        raise typer.Exit(0)

    crl_text = crl.export(
        ca_cert, ca_key, crypto.FILETYPE_TEXT, valid_days, digest.encode("ascii")
    )
    crl_pem = crl.export(
        ca_cert, ca_key, crypto.FILETYPE_PEM, valid_days, digest.encode("ascii")
    )

    with open(crl_file + ".tmp", "wt") as f:
        f.write(crl_text.decode("ascii"))
        f.write(crl_pem.decode("ascii"))
    os.rename(crl_file + ".tmp", crl_file)

    run_post_script(run_post, post_command, {"COMMAND": "CRL_REVOKE", "STAGE": "POST"})


if __name__ == "__main__":
    main_app()
